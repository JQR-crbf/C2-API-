# === 数据模型 (models/user_model.py) ===
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.sql import func
from app.database import Base

class User(Base):
    """用户数据模型"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, comment="用户ID")
    username = Column(String(50), unique=True, nullable=False, comment="用户名")
    email = Column(String(100), unique=True, nullable=False, comment="邮箱")
    full_name = Column(String(100), nullable=True, comment="全名")
    is_active = Column(Boolean, default=True, comment="是否激活")
    created_at = Column(DateTime, default=func.now(), comment="创建时间")
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), comment="更新时间")

    def __repr__(self):
        return f"<User {self.username}>"

    class Config:
        from_attributes = True
```

# === 数据模式 (schemas/user_schema.py) ===
from pydantic import BaseModel, Field, EmailStr
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    """用户基础模式"""
    username: str = Field(..., min_length=3, max_length=50, description="用户名")
    email: EmailStr = Field(..., description="邮箱地址")
    full_name: Optional[str] = Field(None, max_length=100, description="全名")

class UserCreate(UserBase):
    """创建用户请求模式"""
    pass

class UserUpdate(BaseModel):
    """更新用户请求模式"""
    email: Optional[EmailStr] = Field(None, description="邮箱地址")
    full_name: Optional[str] = Field(None, max_length=100, description="全名")
    is_active: Optional[bool] = Field(None, description="是否激活")

class UserQuery(BaseModel):
    """用户查询请求模式"""
    username: Optional[str] = Field(None, description="用户名关键词")
    is_active: Optional[bool] = Field(None, description="激活状态")
    page: int = Field(1, ge=1, description="页码")
    page_size: int = Field(20, ge=1, le=100, description="每页数量")

class UserResponse(UserBase):
    """用户响应模式"""
    id: int = Field(..., description="用户ID")
    is_active: bool = Field(..., description="是否激活")
    created_at: datetime = Field(..., description="创建时间")
    updated_at: datetime = Field(..., description="更新时间")

    class Config:
        from_attributes = True
```

# === 服务层 (services/user_service.py) ===
from sqlalchemy.orm import Session
from sqlalchemy import or_
from typing import List, Optional, Tuple
import logging

from app.models.user_model import User
from app.schemas.user_schema import UserCreate, UserUpdate, UserQuery

logger = logging.getLogger(__name__)

class UserService:
    def __init__(self, db: Session):
        self.db = db

    def create_user(self, user_data: UserCreate) -> User:
        """创建新用户"""
        try:
            # 检查用户名是否已存在
            if self.get_user_by_username(user_data.username):
                raise ValueError("用户名已存在")

            db_user = User(**user_data.dict())
            self.db.add(db_user)
            self.db.commit()
            self.db.refresh(db_user)
            logger.info(f"创建用户成功: {db_user.username}")
            return db_user
        except Exception as e:
            logger.error(f"创建用户失败: {str(e)}")
            self.db.rollback()
            raise

    def get_user_by_username(self, username: str) -> Optional[User]:
        """根据用户名获取用户"""
        return self.db.query(User).filter(User.username == username).first()

    def get_users(self, query: UserQuery) -> Tuple[List[User], int]:
        """获取用户列表"""
        db_query = self.db.query(User)

        # 应用过滤条件
        if query.username:
            db_query = db_query.filter(
                or_(
                    User.username.ilike(f"%{query.username}%"),
                    User.full_name.ilike(f"%{query.username}%")
                )
            )
        if query.is_active is not None:
            db_query = db_query.filter(User.is_active == query.is_active)

        # 获取总数
        total = db_query.count()

        # 分页
        offset = (query.page - 1) * query.page_size
        users = db_query.offset(offset).limit(query.page_size).all()

        return users, total

    def update_user(self, username: str, user_data: UserUpdate) -> Optional[User]:
        """更新用户信息"""
        try:
            db_user = self.get_user_by_username(username)
            if not db_user:
                return None

            # 更新字段
            update_data = user_data.dict(exclude_unset=True)
            for field, value in update_data.items():
                setattr(db_user, field, value)

            self.db.commit()
            self.db.refresh(db_user)
            logger.info(f"更新用户成功: {username}")
            return db_user
        except Exception as e:
            logger.error(f"更新用户失败: {str(e)}")
            self.db.rollback()
            raise
```

# === 路由层 (api/v1/user_api.py) ===
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
import logging

from app.database import get_db
from app.services.user_service import UserService
from app.schemas.user_schema import (
    UserCreate, UserUpdate, UserQuery,
    UserResponse
)
from app.schemas.common import ApiResponse

logger = logging.getLogger(__name__)

router = APIRouter()

@router.post(
    "/",
    response_model=ApiResponse,
    summary="创建用户",
    description="创建新用户，用户名必须唯一"
)
async def create_user(
    user: UserCreate,
    db: Session = Depends(get_db)
):
    """创建用户接口"""
    try:
        service = UserService(db)
        result = service.create_user(user)
        return ApiResponse(
            code=200,
            message="创建用户成功",
            data=UserResponse.from_orm(result).dict()
        )
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"创建用户失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="创建用户失败"
        )

@router.get(
    "/{username}",
    response_model=ApiResponse,
    summary="获取用户信息",
    description="根据用户名获取用户详细信息"
)
async def get_user(
    username: str,
    db: Session = Depends(get_db)
):
    """获取用户信息接口"""
    try:
        service = UserService(db)
        result = service.get_user_by_username(username)
        if not result:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="用户不存在"
            )
        return ApiResponse(
            code=200,
            message="获取用户成功",
            data=UserResponse.from_orm(result).dict()
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"获取用户失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取用户失败"
        )

@router.post(
    "/list",
    response_model=ApiResponse,
    summary="获取用户列表",
    description="获取用户列表，支持分页和筛选"
)
async def get_user_list(
    query: UserQuery,
    db: Session = Depends(get_db)
):
    """获取用户列表接口"""
    try:
        service = UserService(db)
        users, total = service.get_users(query)
        
        return ApiResponse(
            code=200,
            message="获取用户列表成功",
            data={
                "items": [UserResponse.from_orm(user).dict() for user in users],
                "total": total,
                "page": query.page,
                "page_size": query.page_size
            }
        )
    except Exception as e:
        logger.error(f"获取用户列表失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取用户列表失败"
        )
```